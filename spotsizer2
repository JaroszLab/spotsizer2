#!/home/stephankamrad/software/Mathematica/10.04/MathematicaScript -script


(*Set up universal functions*)
CustEucl[x1_, x2_] := EuclideanDistance[x1[[2]], x2[[2]]];
top20mean[inlist_] := Mean[Sort[inlist][[Round[Length[inlist]*0.8, 1] ;;]]];
SetMin[inList_] := Map[(If[# == Min[inList], #, 1000000]) &, inList];

MakeMask[image_] :=
    Module[{mask, intensityThreshold, threshold},
        intensityThreshold = If[hardImageThresholdQ==True, hardImageThreshold, imageThreshold*FindThreshold[image]];
        mask = MorphologicalComponents[image, intensityThreshold];
        threshold = If[hardSizeThresholdQ, hardSizeThreshold, sizeThreshold*ImageDimensions[image][[1]] / 32.0];
        mask = SelectComponents[mask, "Area", (threshold < #) &];
        mask = DeleteBorderComponents[mask];
        Return[mask];
        ];

MakeGrid[cfile_] :=
    Module[{gridSpec, formatConverter, rows, cols, xpos, ypos, grid, gridDist}, 
        gridSpec = Import[cfile, "CSV"][[16]][[2 ;; 6]];
        
        formatConverter = <| 96 -> {8,12}, 384 -> {16,24}, 1536 -> {32,48} |>;
        rows = formatConverter[gridSpec[[1]]][[1]];
        cols = formatConverter[gridSpec[[1]]][[2]];
        
        xpos = Range[gridSpec[[2]],    gridSpec[[4]], (gridSpec[[4]] - gridSpec[[2]])/(cols - 1)];
        ypos = Reverse[Range[gridSpec[[3]], gridSpec[[5]], (gridSpec[[5]] - gridSpec[[3]])/(rows - 1)]];
        (*This is due to awkward indexing. Grid is indexed row,col from bottom left. Image coordinates are x,y from top left*)
        
        grid = Table[{y, x} -> {xpos[[x]], ypos[[y]]}, {x, Length[xpos]}, {y, Length[ypos]}];
        gridDist = grid[[1, 1, 2, 2]] - grid[[1, 2, 2, 2]];
        Return[{grid, gridDist}];
        ];

MatchComponentsToGrid[mask_, baseStr_] :=
    Module[{comPos, distMat, matches, posDict, gridToLabel, ComponentToLabel, labels, labelledImage },
        (*Match positions to grid*)
        comPos = ComponentMeasurements[mask, "Centroid"];
        distMat = DistanceMatrix[Flatten[grid, 1], comPos, DistanceFunction -> CustEucl];
        matches = If[onlyNearestQ, Position[Map[SetMin, distMat], _?(# < (gridDist/distanceThreshold) &)], Position[distMat, _?(# < (gridDist/distanceThreshold) &)]];

        posDict = Table[Flatten[grid, 1][[x[[1]]]][[1]] -> comPos[[x[[2]]]][[1]], {x, matches}];
        
        (*Match grid and labels*) 
        gridToLabel = Table[pos -> StringJoin[ToString[pos[[1]]], "-", ToString[pos[[2]]]], {pos, posDict[[All, 1]]}];
        gtlAssoc = Association[gridToLabel];

        
        ComponentToLabel = Association[Table[Association[posDict][x[[1]]] -> x[[2]], {x, gridToLabel}]];

        (*make QC image and export*)  
        labels = Map[#[[1]] -> (#[[2]] /. comPos) &, posDict];
        labels = Map[((#[[1]] /. gridToLabel ) -> #[[2]]) &, labels];
        labels = Table[{White, Style[Text[comp[[1]], comp[[2]]], FontSize -> 24]}, {comp, labels}]; 
        labelledImage = Show[mask//Colorize, Graphics[labels]];
        Export[StringJoin["spotsizer2_qc/", baseStr, "_mask.png"], labelledImage, "PNG"];
        
        Return[{posDict, gtlAssoc}];
        ];


CFUQ[toAnalyse_] := 
    Module[{analyse},
        analyse[imagePath_] := 
            Module[{image, mask, posDict, headers, data, baseStr}, 
                baseStr = StringSplit[imagePath, "."][[1]];
            
                image = If[negateQ, ColorNegate[Import[imagePath]], Import[imagePath]];
                mask = MakeMask[image];
                posDict = MatchComponentsToGrid[mask, baseStr][[1]];

                headers = {"Row", "Column", "CFU"} ;
                data = Table[{entry[[1]], entry[[2]], If[MemberQ[posDict[[All, 1]], entry], "True", "False"]}, {entry, Flatten[grid[[All, All, 1]], 1]}];
                Export[StringJoin["spotsizer2_results/", baseStr, ".csv"], Join[{headers}, data], "CSV"];
                ];
        If[parallelQ, ParallelDo[analyse[imagePath], {imagePath, toAnalyse}], Do[analyse[imagePath], {imagePath, toAnalyse}]]];

Batch[toAnalyse_] :=
    Module[{analyse},
        analyse[imagePath_] := 
            Module[{image, mask, posDict, headers, data, baseStr, background, backgroundInt}, 
                baseStr = StringSplit[imagePath, "."][[1]];
            
                image = If[negateQ, ColorNegate[Import[imagePath]], Import[imagePath]];
                mask = MakeMask[image];
                posDict = MatchComponentsToGrid[mask, baseStr][[1]];
                gtlAssoc = MatchComponentsToGrid[mask, baseStr][[2]];

                (*Find background intensitiy*)
                background = Table[1, {i, Dimensions[mask][[1]]}, {j, Dimensions[mask][[2]]}] - Unitize[mask];
                backgroundInt = ComponentMeasurements[{background, image}, "MeanIntensity"];
                
                (*Measure area and intensities*)
                areas = Association[ComponentMeasurements[{mask, image}, "Area"]];
                intensities = ComponentMeasurements[{mask, image}, "IntensityData"];
                intensities[[All, 2]] = intensities[[All, 2]] - backgroundInt[[1, 2]];
                intensities = Map[Total, Association[intensities]];
                
                (*Compile table and export*)
                data = Table[{gtlAssoc[x[[1]]], x[[1, 1]], x[[1, 2]], areas[x[[2]]], intensities[x[[2]]]}, {x, posDict}];
                headers = {"Position", "Row", "Column", "Area", "IntegratedIntensity"};

                Export[StringJoin["spotsizer2_results/", baseStr, ".csv"], Join[{headers}, data], "CSV"];
                ];
                
        If[parallelQ, ParallelDo[analyse[imagePath], {imagePath, toAnalyse}], Do[analyse[imagePath], {imagePath, toAnalyse}]]];
        
Timecourse[toAnalyse_] :=
    Module[{analyse, finalImagePath, finalImage, intData, data, finalImageMask, finalImageBaseStr, finalImagePosDict, finalImagegtlAssoc},
        analyse[imagePath_, mask_] := 
            Module[{image, background, backgroundInt, intensities}, 
            
                image = If[negateQ, ColorNegate[Import[imagePath]], Import[imagePath]];
                
                (*Find background intensitiy*)
                background = Table[1, {i, Dimensions[mask][[1]]}, {j, Dimensions[mask][[2]]}] - Unitize[mask];
                backgroundInt = ComponentMeasurements[{background, image}, "MeanIntensity"];
                
                (*Measure intensities*)
                intensities = ComponentMeasurements[{mask, image}, "IntensityData"];
                intensities[[All, 2]] = intensities[[All, 2]] - backgroundInt[[1, 2]];
                intensities = Map[Total, Association[intensities]];                
                Return[intensities];
                ];
        
        finalImagePath = toAnalyse[[-1]];
        finalImage = If[negateQ, ColorNegate[Import[finalImagePath]], Import[finalImagePath]];
        finalImageMask = MakeMask[finalImage];
        finalImageBaseStr = StringSplit[finalImagePath, "."][[1]];
        finalImagePosDict = MatchComponentsToGrid[finalImageMask, finalImageBaseStr][[1]];
        finalImagegtlAssoc = MatchComponentsToGrid[finalImageMask, finalImageBaseStr][[2]];

        If[parallelQ, intData = ParallelTable[analyse[imagePath, finalImageMask], {imagePath, toAnalyse}], intData = Table[analyse[imagePath, finalImageMask], {imagePath, toAnalyse}]];
        
        (*Compile table and export*)
        data = Transpose[Table[Table[entry[x[[2]]], {entry, intData}], {x, finalImagePosDict}]];
        headers = Table[finalImagegtlAssoc[x[[1]]], {x, finalImagePosDict}];
        Export[StringJoin["spotsizer2_results/", finalImageBaseStr, ".csv"], Join[{headers}, data], "CSV"];
        ];

(*Main block*)
Print["Welcome to Spotsizer2"];
Print[StringJoin["The working directory is: ", Directory[]]];

configPath = If[FileExistsQ["spotsizer2.config"], "spotsizer2.config", StringJoin[$ScriptCommandLine[[1]], ".config"]];
If[FileExistsQ["spotsizer2.config"], Print["Reading local spotsizer2.config file."], Print["spotsizer2.config file not found in current directory. Reading default parameters."]];
If[FileExistsQ["spotsizer2.config"], Get["spotsizer2.config"], Get[StringJoin[$ScriptCommandLine[[1]], ".config"]]];

On[Assert];
Assert[BooleanQ[parallelQ]];
Assert[imageThreshold > 0];
Assert[distanceThreshold > 2];
Assert[sizeThreshold > 0];
Assert[BooleanQ[negateQ]];
Assert[BooleanQ[onlyNearestQ]];
Assert[BooleanQ[hardImageThresholdQ]];
Assert[BooleanQ[hardSizeThresholdQ]];
Print["Using the following parameters:"];
Print["parallelQ: ", parallelQ];
Print["distanceThreshold: ", distanceThreshold];
Print["imageThreshold: ", imageThreshold];
Print["sizeThreshold: ", sizeThreshold];
Print["negateQ: ", negateQ];
Print["onlyNearestQ: ", onlyNearestQ];
Print["hardImageThresholdQ: ", hardImageThresholdQ];
If[hardImageThresholdQ, Print["hardImageThreshold: ", hardImageThreshold]];
Print["hardSizeThresholdQ: ", hardSizeThresholdQ];
If[hardSizeThresholdQ, Print["hardSizeThreshold: ", hardSizeThreshold]];

CreateDirectory["spotsizer2_results"];
CreateDirectory["spotsizer2_qc"];

(*Find image files and analyse*)
toAnalyse = FileNames[{"*.JPG", "*.jpg", "*.PNG", "*.png", "*.TIFF", "*.tiff"}];
Print["Spotsizer2 will analyse the following images:"];
Print[toAnalyse];

(*Load grid*)
Print["Reading Colonyzer.txt file."];
gridResult = MakeGrid["Colonyzer.txt"];
grid = gridResult[[1]];
gridDist = gridResult[[2]];

(*Run*)
If[parallelQ,LaunchKernels[$ProcessorCount]];
cmd = $ScriptCommandLine[[-1]];
Print[StringJoin["Running analysis in ", cmd, " mode."]];

Which[cmd=="cfuq", CFUQ[toAnalyse],
      cmd=="timecourse", Timecourse[toAnalyse],
      cmd=="batch", Batch[toAnalyse]
      ];
Print["Done."];
